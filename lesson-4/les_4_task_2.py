'''
Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное
и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте
его улучшить/оптимизировать под задачу.
Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.
Пример работы программ:

>>> sieve(2)
3
>>> prime(4)
7
>>> sieve(5)
11
>>> prime(1)
2

Примечание по профилированию кода: для получения достоверных результатов при замере времени необходимо
исключить/заменить функции print() и input() в анализируемом коде. С ними вы будете замерять время вывода данных
 в терминал и время, потраченное пользователем, на ввод данных, а не быстродействие самого алгоритма.

'''

# 1. Поиск простых чисел с помощью Решета Эратосфена.
import math


def sieve(max_count):

    list_len = int(max_count*math.log(max_count)*1.4)+2
    nums = [i for i in range(2, list_len+2)]

    for num in nums:
        if num != 0:
            for candidate in range(pow(num, 2), list_len, num):
                nums[candidate-2] = 0

    counter = 0
    for i in nums:
        if i != 0:
            counter += 1
            if counter == max_count:
                return i


print(sieve(int(input('Введите порядковый номер простого числа: '))))

# Скорость выполнения алгоритма - см. файл "task_2_profiling_variant_1.py"
# Вычислительная сложность алгоритма: O(n*log*(log n))


# 2. Поиск простых чисел с помощью поиска делителей для каждого числа из списка.

def prime(max_count):

    list_len = int(max_count*math.log(max_count)*1.4)+2
    nums = [i for i in range(2, list_len+2)]

    for num in nums:

        i = 2
        while i <= math.sqrt(num):
            if num % i == 0:
                nums[num-2] = 0
                break

            i += 1

    counter = 0
    for i in nums:
        if i != 0:
            counter += 1
            if counter == max_count:
                return i


print(prime(int(input('Введите порядковый номер простого числа: '))))

# Скорость выполнения алгоритма - см. файл "task_2_profiling_variant_2.py"
# Вычислительная сложность алгоритма: O(n*sqrt(n))
