'''
Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать,
b. написать 3 варианта кода (один у вас уже есть),
c. проанализировать 3 варианта и выбрать оптимальный,
d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
e. написать общий вывод: какой из трёх вариантов лучше и почему.

'''

# a. Выбрана задача lesson 3 task 2:
# Во втором массиве сохранить индексы четных элементов первого массива.
# Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, второй массив надо заполнить значениями 0, 3, 4, 5
# (помните, что индексация начинается с нуля), т. к. именно в этих позициях первого массива стоят четные числа.
#
# Обоснование выбора: у этой задачи есть несколько вариантов решения с разной эффективностью.

# b. Варианты решения:
# Вариант №1:
import random

N = 100
a = [random.randint(0, 100) for i in range(N)]
b = []

for i, j in enumerate(a):
    if j % 2 == 0:
        b.append(i)

print(f'Исходный массив: {a}')
print(f'Индексы четных элементов: {b}')


# Вариант №2 (используем один цикл):
N = 100
a = []
b = []

for i in range(N):
    a.append(random.randint(0, 100))
    if a[i] % 2 == 0:
        b.append(i)

print(f'Исходный массив: {a}')
print(f'Индексы четных элементов: {b}')


# Вариант №3 (используем два list comprehension):
N = 100
b = [i for i, j in enumerate([random.randint(0, 100)
                              for i in range(N)]) if j % 2 == 0]
print(f'Исходный массив: {a}')
print(f'Индексы четных элементов: {b}')


# c. По результатам замеров (см. файлы "task_1_profiling_variant_N.py") самый эффективный (с т.з. скорости) - вариант №3.
# Однако эффект от оптимизации незначителен - на выборке из 50000 элементов x 1000 повторов прирост скорости
# составил 1.8сек. по сравнению с самым медленным вариантом.

# d. Результаты замеров см. в файлах "task_1_profiling_variant_N.py"

# e. Самым эффективным (с т.з. скорости) оказался Вариант №3 по причине того,
# что list comprehension в целом работают быстрее обычных циклов "for".
# Вычислительная сложность всех трех алгоритмов составляет O(n).


# Примечание. В ходе решения задачи испробован альтернативный способ определения четности: "not a[i] & 1".
# Этот способ не дал прироста скорости по сравнению с проверкой остатка от деления на 2.
